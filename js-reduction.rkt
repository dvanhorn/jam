#lang racket
(require redex)
(require "js-lang.rkt")
(provide (all-defined-out))

(define Î»ÏJS-step
  (reduction-relation 
   JS #:domain ð“¼
   ;; Final answer
   (--> (Ïƒ v) (val v Ïƒ))
   
   ;; Environment elimination rules
   (==> (clos q Ï) q)
   (==> (clos (func (x ...) e) Ï) ((func (x ...) e) Ï))
   
   ;; Environment propagation rules   
   (==> (clos (rec (s e) ...) Ï)
        (rec (s (clos e Ï)) ...))
   (==> (clos (let (x e_0) e_1) Ï)
        (let (x (clos e_0 Ï)) (clos e_1 Ï)))
   (==> (clos (app e_0 e_1 ...) Ï)
        (app (clos e_0 Ï) (clos e_1 Ï) ...))
   (==> (clos (rec-ref e_0 e_1) Ï)
        (rec-ref (clos e_0 Ï) (clos e_1 Ï)))
   (==> (clos (rec-set e_0 e_1 e_2) Ï)
        (rec-set (clos e_0 Ï) (clos e_1 Ï) (clos e_2 Ï)))
   (==> (clos (rec-del e_0 e_1) Ï)
        (rec-del (clos e_0 Ï) (clos e_1 Ï)))
   (==> (clos (set e_0 e_1) Ï)
        (set (clos e_0 Ï) (clos e_1 Ï)))
   (==> (clos (ref e) Ï)
        (ref (clos e Ï)))
   (==> (clos (deref e) Ï)
        (deref (clos e Ï)))
   (==> (clos (if e_0 e_1 e_2) Ï)
        (if (clos e_0 Ï) (clos e_1 Ï) (clos e_2 Ï)))
   (==> (clos (begin e_0 e_1) Ï)
        (begin (clos e_0 Ï) (clos e_1 Ï)))
   (==> (clos (label l e) Ï)
        (label l (clos e Ï)))
   (==> (clos (break l e) Ï)
        (break l (clos e Ï)))
   (==> (clos (try/catch e_0 x e_1) Ï)
        (try/catch (clos e_0 Ï) x (clos e_1 Ï)))
   (==> (clos (try/finally e_0 e_1) Ï)
        (try/finally (clos e_0 Ï) (clos e_1 Ï)))
   (==> (clos (throw e) Ï)
        (throw (clos e Ï)))
   (==> (clos (prim op e ...) Ï)
        (prim op (clos e Ï) ...))
   
   ;; While expansion
   (==> (clos (while e_0 e_1) Ï)
        (clos (if e_0 (begin e_1 (while e_0 e_1)) undefn) Ï))
   
   ;; Context-insensitive, store-insensitive rules
   (==> (clos x Ï)
        (env-lookup x Ï))
   (==> (let (x v) (clos e Ï))
        (clos e (env-extend (x) (v) Ï)))
   (==> (app ((func (x ..._1) e) Ï) v ..._1)
        (clos e (env-extend (x ...) (v ...) Ï)))
   (==> (app ((func (x ..._!_1) e) Ï) v ..._!_1)
        (throw "Arity mismatch"))
   (==> (app v v_0 ...)
        (throw "Not a function")
        (side-condition (not (term (function? v)))))
   (==> (rec-ref (rec (s v) ...) s_0)
        (rec-lookup ((s v) ...) s_0))   
   (==> (rec-ref v_0 v_1)
        (throw "Bad record ref")
        (side-condition (or (not (term (record? v_0)))
                            (not (term (string? v_1))))))   
   (==> (rec-set (rec (s v) ...) s_0 v_0)
        (rec-update ((s v) ...) s_0 v_0))   
   (==> (rec-set v_0 v_1 v_2)
        (throw "Bad record set")
        (side-condition (or (not (term (record? v_0)))
                            (not (term (string? v_1))))))
   (==> (rec-del (rec (s v) ...) s_0)
        (rec-delete ((s v) ...) s_0))
   (==> (rec-del v_0 v_1)
        (throw "Bad record del")
        (side-condition (or (not (term (record? v_0)))
                            (not (term (string? v_1))))))   
   (==> (if true c_0 c_1) c_0)   
   (==> (if false c_0 c_1) c_1)   
   (==> (if v c_0 c_1)
        (throw "Not a boolean")
        (side-condition (not (term (boolean? v)))))
   (==> (begin v c) c)
   (==> (try/catch v x (clos e Ï)) v)
   (==> (try/finally v c) 
        (begin c v))
   (==> (label l v) v)   
   ;; Inlined the well-defined cases in order to make testing feasible.
   #;
   (==> (prim op v ...)
        (Î´ op v ...)
        (side-condition (term (in-Î´-dom? op v ...))))
   (==> (prim + n_0 n_1)
        (Î´ + n_0 n_1))
   (==> (prim number->string n)
        (Î´ number->string n))
   (==> (prim op v ...)
        (throw "Bad primop")
        (side-condition (not (term (in-Î´-dom? op v ...)))))
      
   ;; Context-sensitive, store-sensitive rules
   (--> (Ïƒ (in-hole ð“” (ref v)))
        ((sto-extend n v Ïƒ) (in-hole ð“” (addr n)))
        (where n (sto-alloc Ïƒ)))        
   (--> (Ïƒ (in-hole ð“” (deref (addr n))))
        (Ïƒ (in-hole ð“” (sto-lookup Ïƒ n)))
        (side-condition (term (in-sto-dom? Ïƒ n))))     
   (--> (Ïƒ (in-hole ð“” (deref (addr n))))
        (Ïƒ (in-hole ð“” (throw "Null pointer")))
        (side-condition (not (term (in-sto-dom? Ïƒ n)))))   
   (==> (deref v)
        (throw "Not an address")
        (side-condition (not (term (address? v)))))   
   (--> (Ïƒ (in-hole ð“” (set (addr n) v)))
        ((sto-update Ïƒ n v) (in-hole ð“” v))
        (side-condition (term (in-sto-dom? Ïƒ n))))   
   (--> (Ïƒ (in-hole ð“” (set (addr n) v)))
        (Ïƒ (in-hole ð“” (throw "Null pointer")))
        (side-condition (not (term (in-sto-dom? Ïƒ n)))))   
   (==> (set v_0 v_1)
        (throw "Not an address")
        (side-condition (not (term (address? v_0)))))
   (--> (Ïƒ (in-hole ð“’ (throw v)))
        (err v Ïƒ))
   (==> (try/finally (in-hole ð“’ (throw v)) c)
        (begin c (throw v)))
   (==> (try/catch (in-hole ð“’ (throw v)) x (clos e Ï))
        (clos e (env-extend (x) (v) Ï)))   
   (==> (label l (in-hole ð“’ (throw v)))
        (throw v))
   (--> (Ïƒ (in-hole ð“’ (break l v)))
        (Ïƒ (in-hole ð“’ (throw "Unlabeled break"))))
   (==> (try/finally (in-hole ð“’ (break l v)) c)
        (begin c (break l v)))
   (==> (try/catch (in-hole ð“’ (break l v)) x (clos e Ï))
        (break l v))
   (==> (label l (in-hole ð“’ (break l v)))
        v)
   (==> (label l_0 (in-hole ð“’ (break l_1 v)))
        (break l_1 v)
        (side-condition (not (equal? (term l_0) (term l_1)))))                      
   with
   [(--> (Ïƒ (in-hole ð“” c_0)) (Ïƒ (in-hole ð“” c_1)))
    (==> c_0 c_1)]))
  


